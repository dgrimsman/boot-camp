---
title: "first_glance"
bibliography: boot-camp.bib
csl: poetics.csl
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Scientific Questions

Routing algorithms in the ocean are hard [@christiansen_ship_2004].

What kind of questions and results are we looking for?

- Q: How can we improve routing from a simple grid?
  
  - A: [Generic] Use triangulated network. Compare distances between start/end points.
  
  - A: [Application] Compare with extra whale risk conserved & less shipping distance traversed for this example. Results:
  
    - Show boxplot of grid vs triangulated routing and efficiencies gained on y axis for whales & shipping
    
    - Show plot of how parameter for triangulation (like angle) on x-axis changes, how efficincies are gained in whale conservation / shipping distance on y-axis 
    
    - Showing the Shiny app before/after this new routing mechanism. Embedded as a HTML slideshow.
  
- Q: How can we improve routing from a simple grid?


## Technical Questions

Let's try to use <https://github.com/dgrimsman/boot-camp/issues>.

## Data

British Columbia (BC)

- land: `bc_spp_gcs.shp`
- whales: `v72zw_epsg3857.grd`

### raster of whale hot spots

```{r whales, message=F}
library(raster) # install.packages('rgdal')

whales = raster('data/v72zw_epsg3857.grd')
plot(whales)
```

### ports to route between

```{r ports, message=FALSE}
library(readr)

ports = read_csv('data/ports_bc.csv')
```


### interactive map

```{r}
library(leaflet)

leaflet() %>%
  addProviderTiles("Stamen.TonerLite", options = providerTileOptions(noWrap = TRUE)) %>% 
  addRasterImage(
    whales, opacity = 0.8, project = F, group='Raster',
    colors = colorNumeric(
      palette = 'Reds', domain = c(cellStats(whales, 'min'), cellStats(whales, 'max')), 
      na.color = "#00000000", alpha = TRUE)) %>%
  addCircleMarkers(
    ~lon, ~lat, color='blue', data=ports, layerId=~name, group='Ports',
    popup = ~sprintf('<b>%s</b><br>%0.2f, %0.2f', name, lon, lat)) %>%
  addLayersControl(
    overlayGroups = c('Raster', 'Ports'),
    options = layersControlOptions(collapsed=T))
```

## Testing New Packages

### RBGL

```{r install, eval=FALSE}
source("https://bioconductor.org/biocLite.R")
biocLite("RBGL")
```

```{r}
library(RBGL)

# astar search
con <- file(system.file("XML/dijkex.gxl",package="RBGL"), open="r")
coex <- fromGXL(con)
close(con)
astarSearch(coex)
```

### RTriangle

- [Computational Geometry in Python](http://blancosilva.github.io/post/2014/10/28/Computational-Geometry-in-Python.html#convex-hulls)

- [Triangle: .poly files](http://www.cs.cmu.edu/~quake/triangle.poly.html)

```{r}
library(RTriangle)

## Create an object with a concavity
p <- pslg(P=rbind(c(0, 0), c(0, 1), c(0.5, 0.5), c(1, 1), c(1, 0)),
          S=rbind(c(1, 2), c(2, 3), c(3, 4), c(4, 5), c(5, 1)))

## Plot it
plot(p)

## Triangulate it
tp <- triangulate(p)
plot(tp)

## Load a data set containing a hole
A <- read.pslg(file.path(system.file(package = "RTriangle"), "extdata", "A.poly"))
plot(A)
## Triangulate the PSLG
tA <- triangulate(A)
plot(tA)
## Triangulate the PSLG with triangles in which no angle
## is smaller than 20 degrees
tA <- triangulate(A, q=20)
plot(tA)
## Triangulate the PSLG with triangles in which no triangle has 
## area greater than 0.001
tA <- triangulate(A, a=0.001)
plot(tA)

source('custom.R')
ply = read.pslg('data/superior.poly')
plot(ply)
t_ply <- triangulate(ply)
plot(t_ply)
t_ply <- triangulate(ply, q=20, D=T) # 'pq20D'
plot(t_ply)
```

## Triangulate BC

[Triangularize BC raster · Issue #1 · dgrimsman/boot-camp](https://github.com/dgrimsman/boot-camp/issues/1)

### Get Extent Polygon of Raster

```{r create bc.geojson, eval=FALSE}
whales_1 = whales
whales_1[!is.na(whales_1)] = 1
plot(whales_1)
whales_p = rasterToPolygons(whales_1, n=8, na.rm=T, digits=12, dissolve=T)
plot(whales_p)

writeOGR(whales)
library(rgdal)
writeOGR(whales_p, 'data/bc', layer='layer', driver='GeoJSON')
file.rename('data/bc','data/bc.geojson')
```

```{r, eval=F}
library(rgeos)
library(RTriangle)
library(dplyr)

whales_p = readOGR(dsn='data/bc.geojson', layer='OGRGeoJSON')

names(whales_p)
slotNames(whales_p)
whales_p@polygons

vertices = data_frame(i=numeric(), x=numeric(), y=numeric())
for (i in 1:length(whales_p@polygons[[1]]@Polygons)){ # p = whales_p@polygons[[1]]@Polygons[1]
  vertices = bind_rows(
    vertices,
    a = whales_p@polygons[[1]]@Polygons[[i]]@coords %>%
      as.data.frame() %>%
      mutate(i = i))
}

# http://www.cs.cmu.edu/~quake/triangle.poly.html
# DONE: @bbest
# First line: <# of vertices> <dimension (must be 2)> <# of attributes> <# of boundary markers (0 or 1)>
# Following lines: <vertex #> <x> <y> [attributes] [boundary marker]
poly = 'data/bc.poly'
write_file(sprintf('%d 2 0 0\n', nrow(vertices)), poly)
for (i in 1:nrow(vertices)){ # i =1
  row = vertices[i,]
  write_file(sprintf('%d %g %g\n', i, row$x, row$y), poly, append=T)
}

# TODO: @dgrimsman
# One line: <# of segments> <# of boundary markers (0 or 1)>
# Following lines: <segment #> <endpoint> <endpoint> [boundary marker]

#bc_poly = read.pslg('data/bc.poly') # not yet working b/c segments needed
#plot(bc_poly)
#bc_poly <- triangulate(ply, q=20, D=T) # 'pq20D'
#plot(bc_poly)
```


## R Tips Background

- [HTML Documents - rmarkdown](http://rmarkdown.rstudio.com/html_document_format.html#code_folding)
- [Bibliographies and Citations](http://rmarkdown.rstudio.com/authoring_bibliographies_and_citations.html)
- [bbest/rmarkdown-example: R Markdown example showing figures & tables with captions, equations, inline R values and references with a Zotero library](https://github.com/bbest/rmarkdown-example)


## References

